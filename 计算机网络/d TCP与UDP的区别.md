# TCP与UDP的	区别

### TCP和UDP是OSI模型中的传输层中的协议；TCP提供可靠的通信传输，而UDP则是常被用于让广播和细节控制交给应用的通信传输；

## UDP（User Datagram Protocol）：

1. UDP**不提供复杂的控制机制**，利用IP**面向无连接**的通信服务；
2. 即使是出现在**网络拥堵**的情况下，UDP也无法进行流量控制等避免网络拥塞的行为（**无法进行流量控制**）；
3. 在传输过程中，如果出现了丢包，UDP也不负责重发（**不会丢失重传**）；
4. 甚至当出现包到达时，顺序乱掉时也没有纠正的功能（**不具备顺序控制**）；
5. 要实现细节控制，只能交给采用UDP的应用程序去处理；
6. 换句话说，UDP将部分控制转移到应用程序去处理，自己却只提供作为传输层协议的最基本的功能；
7. 适用于**高速传输、实时性较高要求**的通信或广播通信；

## TCP（Transmission Control Protocol）：

1. TCP实现了数据传输时各种控制功能，可以进行**丢包重发**、次序乱掉时的分包进行**顺序控制**；
2. TCP作为一种**面向有链接**的协议，只有在确认通信时才会发送数据，从而**控制通信的流量**的浪费；
3. TCP通过**检验和、序列号、确认应答、重发控制、连接管理以及窗口控制**等机制**实现可靠性传输**、
4. TCP属于传输层，**提供可靠的字节流服务**；字节流其实类似于**信息切割**，为了方便传输，**将大数据分割成报文段为单位的数据包进行管理**，而可靠的传输服务是指，**能够把数据准确可靠地传给对方**；比如你是卖自行车的，你要去送货，安装好的自行车太过庞大，又不稳定，容易损伤，所以这个时候不如直接将自行车拆开来，每个零件上都贴上收件人的姓名，到达目的地后，按照把属于同一个人的自行车在组装起来；这个拆解、运输、安装过程就是TCP字节流传输过程；

## TCP与UDP的区别：

1. TCP面向连接；UDP面向无连接的（**是否面向连接**）；
2. TCP提供可靠的服务，通过TCP传输的数据，**无差错，不丢失，不重复，不乱序**；而UDP则是尽最大努力交付，即不保证可靠交付（**交付是否可靠，数据正确性**）；
3. TCP面向字节流，实际上是TCP把数据看成是一连串无结构的字节流；而UDP是面向报文的，UDP没有拥塞控制，因此网络出现拥塞时不会对源主机的发送速率降低（**TCP面向流模式，UDP面向数据报模式；网络是否会拥塞控制**）；
4. 每一天TCP连接只能是点到点的；而UDP支持一对一，一对多，多对一和多对多的交互通信；
5. TCP的首部开销是20个字节；而UDP的首部的开销是8字节（**程序结构，首部字节**）；
6. TCP的逻辑通信信道是全双工的可靠通信；而UDP则是不可靠的信道（**信道是否可靠**）；

## 编程区别：

1. 我们通常所说的**网络编程**默认是指**TCP编程**，即用前面提到的socket函数创建一个socket用于TCP通讯，函数参数我们通常填为**SOCK_STREAM**；即socket（PF_INET，SOCK_STREAM，0），这表示建立一个socket用于**流式编程**；
2. **SOCK_STREAM**这种的特点是**面向连接**的，即每次收发数据**之前必须通过connect建立连接**，也是**双向**的，即任何一方都可以收发数据，协议本身提供了一些**保障**机制保证它是**可靠的**、**有序的**，即每个包按照发送的**顺序到达**接收方；
3. **SOCK_DGRAM**这种是UDP协议的网络通讯，它是**无连接的**，**不可靠的**，因为通讯双方发送数据后不知道对方是否已经接收到数据，是否正常接收数据；任何一方建立一个socket以后就可以用sendto发送数据，也可以用recvfrom接收数据；根本**不关心对方是否存在**，是否发送了数据；它的特点是**通讯速度比较快**；TCP需要**三次握手，四次挥手**；而UDP不用；

## TCP的三次握手与四次挥手：

### 先看看TCP的三次握手，四次挥手的完整过程：

![](https://i.imgur.com/dxGltiI.jpg)

### TCP三次握手：

首先Client端发送连接请求报文，Server端接受连接后回复ACK报文，并为这次连接**分配资源**；Client端收到ACK报文后也向Server端发送ACK报文，并**分配资源**，这样TCP连接就建立了；

![](https://i.imgur.com/wVJXddY.png)  ![](https://i.imgur.com/ihkSABm.png)

### TCP四次挥手：

![](https://i.imgur.com/YaVjqtf.png)

**【注意】中断连接端可以是Client端，也可以是Server端。**

##### 四次挥手步骤（结合上图理解）：

1. 假设Client端发起中断连接请求，也就是发送FIN报文。
   
2. Server端接到FIN报文后，意思是说"我Client端没有数据要发给你了"，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。

3. 所以Server端先发送ACK，"告诉Client端，你的请求我收到了，但是我还没准备好，请继续你等我的消息"。

4. 这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文。

5. 当Server端确定数据已发送完成，则向Client端发送FIN报文，"告诉Client端，好了，我这边数据发完了，准备好关闭连接了"。

6. Client端收到FIN报文后，就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以Client端发送ACK后进入**TIME_WAIT状态**，如果Server端**没有收到ACK则可以重传**。

7. Server端收到ACK后，"就知道可以断开连接了"。

8. Client端等待了**2MSL**后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！

**【注意】 在TIME_WAIT状态中，如果TCP client端最后一次发送的ACK丢失了，它将重新发送。TIME_WAIT状态中所需要的时间是依赖于实现方法的。典型的值为30秒、1分钟和2分钟。等待之后连接正式关闭，并且所有的资源(包括端口号)都被释放**

#### 【问题1】为什么连接的时候是三次握手，关闭的时候却是四次握手？

答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。

#### 【问题2】为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？

答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们**必须假象网络是不可靠的**，有可以最后一个ACK丢失。所以**TIME_WAIT状态**就是**用来重发可能丢失的ACK报文**。

#### 【问题3】为什么TCP非要进行三次握手而不是两次握手呢？

答：因为**为了防止已失效的连接请求报文段突然又传送到服务端**；

举个例子：“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是**在某个网络结点长时间的滞留了**，以致延误到连接释放以后的某个时间才到达server；本来是一个早已失效的报文段；但server收到此失效的连接请求报文段后，就误认为client再次发出一个新的连接请求；于是就向client发出确认报文段，同意建立连接；

假设不采用“三次握手”，那么server发出确认，新的连接就建立了，由于现在client不会理睬server的确认，也不会向server发送数据，但server认为新的运输连接已经建立，并一直等待client发来的数据，这样，server的很多资源就浪费掉了；

采用“三次握手”的办法可以防止上述现象发生，client不会向server的确认发出确认，server由于收不到确认，就知道client并没有要求建立连接；**为了防止服务端一直等待而浪费资源**；