#第二章 IPC机制

##2.1 Android IPC简介

1. **线程与进程的区别**：

 	i.**线程**是CPU调度的**最小单元**，同时线程是一种**有限**的系统资源；

 	ii.而**进程**一般指一个**执行单元**，在PC和移动设备上指**一个程序或者一个应用**；

 	iii.**一个进程可以包含多个线程**，因此进程与线程是**包含与被包含**的关系；最简单的一种情况，一个进程种可以只有一个线程，即主线程，在Android里面主线程就是**UI线程**，在UI线程才能操作界面元素；

2. 任何一个操作系统都需要有相应的IPC机制，**每个操作系统的IPC机制都不同**；在Android中**最有特色**的进程间通信方式就是**Binder**，通过Binder可以轻松地实现进程间通信；除了Binder，Android还支持Socket，通过**Socket**也可以是实现**任意两个终端之间的通信**，当然**同一个设备上的两个进程**也可以通过Socket通信；

3. IPC的使用场景是**多进程**，**只有**面对多进程的场景下，才需要考虑进程间通信；多进程的情况分为两种：

 	i.一个应用因为**自身的某些原因**需要采用多进程模式来实现：

		1.有些模块由于特殊原因需要运行在单独的进程中；

		2.加大一个应用可使用的内存所以需要通过多进程来获取多份内存空间；

 	ii.当前应用需要**向其他应用获取数据**：采用**跨进程**的方式获取数据，甚至**通过系统**提供的**ContentProvide**去查询数据的时候；

##2.2 Android中的多进程模式

###2.2.1 开启多进程模式

1.在Android中使用多进程**只有一种方法**，就是给**四大组件**在AndroidManifest中指定**android：process属性**，除此之外没有其他方法，无法给一个线程或者一个实体类指定其运行时所在的进程；还有一种非常规的方法，就是通过JNI在native层去fork一个新的进程（**特殊情况**）；

2.进程名**以“：”开头**的进程为**私有进程**，其他应用的组件**不可以和它跑在同一个进程中**；而进程名**不以“：”开头**的进程属于**全局进程**，其他应用**通过ShareUID方式**（相同的ShareUID与相同的签名）可以和它**跑在同一个进程中**；具有**相同UID**的应用才能共享数据；

3.非同一进程，共享data目录、组件信息；同一进程，共享data目录、组件信息、内存数据；

###2.2.2 多进程模式的运行机制

1.所有运行**在不同进程**的四大组件，只要他们之间需**要通过内存来共享数据**，都会**共享失败**，这也是多进程带来的主要影响；

2.使用多进程会造成如下问题：

	i.静态成员和单例模式完全失效；

	ii.线程同步机制完全失效；

	iii.SharedPreferences的可靠性下降（不支持两个进程同时去执行写操作）；

	iv.Application会被多次创建（系统在创建新的进程同时分配独立的虚拟机，相当于启动一个应用的过程）；

3.在多进程的模式中，**不同进程的组件**的确会**拥有独立的虚拟机、Application以及内存空间**；

4.**同一个应用中的多进程**：相当于**两个不同的应用**采用SharedUID的模式，实现进程间通信；

##2.3 IPC基础概念介绍

###2.3.1 Serializable接口

1.想让一个对象实现序列化，只需要这个类**实现Seriallizable接口**并**声明一个serialVersionUID**即可；实际上，serialVersionUID也不是必须的，但是如果我们不声明这个serialVersionUID，同样可以序列化，但是这将会对反序列化产生影响；

2.serialVersionUID的详细工作机制是这样的：序列化的时候系统会把当前类的**serialVersionUID**写入序列化的文件中（也可能是其他中介），当反序列化的时候系统会**去检测**文件中的serialVersionUID，看他**是否和当前类的serialVersionUID一致**，如果一致就说明序列化的类的版本和当前类的版本是相同的，这个时候可以成功反序列化；否则就说明当前类和序列化的类相比**发生了变换**，比如成员变量的数量、类型发生了改变，无法正常序列化；

###2.3.2 Parcelable接口

1.**Serializable是Java中**的序列化接口，其使用起来**简单但是开销很大**，序列化和反序列化过程**需要大量的I/O操作**；而**Parcelable是Android中**的序列化方式，因此更适合在Android平台上，他的缺点就是使用起来稍微麻烦点，但是它的**效率很高**，这是Android推荐的序列化方式；

2.**Parcelable主要用在内存序列化上**，通过Parcelable将对象序列化到存储设备上或者将对象序列化后通过网络传输也都是可以的，但是这个会稍显复杂，因此在将对象序列化到**存储到设备上或网络传输时使用Serializable**；

###2.3.3 Binder：

1.Binder是Android中的一种**跨进程通信方式**，Binder还可以理解为一种虚拟的物理设备，他的设备驱动是**/dev/binder**，该通信方式在Linux中没有（**管道通信、共享内存**）；

2.从**Android Framework**角度来说，Binder是ServiceManager连接**各种Manager**（ActivityManager、WindowManager等等）和**相应的ManagerService**的桥梁；

3.从Android应用层来说，Binder是客户端与服务端进行通信的媒介，当bindService的时候，服务端会返回一个包含了服务端业务调用的Binder对象，通过这个对象，客户端就可以获取服务端提供的服务或数据，这里的服务包括普通服务和基于AIDL的服务；